name: CI/CD Microservices

on:
  push:
    branches: [ main, develop, 'feature/*' ]
  pull_request:
    branches: [ main, develop ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: medi-supply-cluster
  MIN_COVERAGE: 80


jobs:
  # 1) Detecta microservicios modificados y expone salida JSON (una sola l√≠nea)
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed-services: ${{ steps.changes.outputs.changed-services }}
      pr-number: ${{ steps.pr-info.outputs.number }}
      pr-title: ${{ steps.pr-info.outputs.title }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi
      - name: PR Information
        id: pr-info
        if: github.event_name == 'pull_request'
        run: |
          echo "number=${{ github.event.number }}" >> $GITHUB_OUTPUT
          echo "title=${{ github.event.pull_request.title }}" >> $GITHUB_OUTPUT
          echo "üîç PR #${{ github.event.number }}: ${{ github.event.pull_request.title }}"
      - name: Detect Changed Services
        id: changes
        shell: bash
        run: |
          echo "üîç Detectando microservicios modificados..."
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.base_ref }}"
            echo "üìã Comparando con base branch: $BASE"
            # Asegura que exista la rama base localmente
            git fetch origin "$BASE:$BASE" --depth=1
          else
            BASE="HEAD~1"
            echo "üìã Comparando contra commit anterior"
          fi
          CHANGED_FILES=$(git diff --name-only "$BASE"...HEAD || true)
          SERVICES_JSON='[]'
          for dir in services/*/; do
            [[ -d "$dir" ]] || continue
            s=$(basename "$dir")
            if echo "$CHANGED_FILES" | grep -q "^services/$s/"; then
              echo "‚úÖ $s: CAMBIOS DETECTADOS"
              # -c = salida compacta en una sola l√≠nea
              SERVICES_JSON=$(jq -c --arg svc "$s" '. + [$svc]' <<<"$SERVICES_JSON")
            else
              echo "‚è≠Ô∏è  $s: Sin cambios"
            fi
          done
          # Fallback m√≠nimo: si solo cambi√≥ el workflow, correr tests en servicios con pruebas
          if [[ "$SERVICES_JSON" == '[]' ]] && echo "$CHANGED_FILES" | grep -q "^.github/workflows/ci-cd.yml$"; then
            echo "üß™ Fallback: ejecutando pruebas en servicios con configuraci√≥n de tests"
            for dir in services/*/; do
              [[ -d "$dir" ]] || continue
              s=$(basename "$dir")
              if [[ -f "services/$s/pytest.ini" ]] || find "services/$s" -maxdepth 2 -type f -name "test_*.py" | grep -q .; then
                SERVICES_JSON=$(jq -c --arg svc "$s" '. + [$svc]' <<<"$SERVICES_JSON")
              fi
            done
          fi
          echo "üìä Servicios a procesar (JSON): $SERVICES_JSON"
          # Escribir output en UNA sola l√≠nea evita el error "Invalid format"
          echo "changed-services=$SERVICES_JSON" >> "$GITHUB_OUTPUT"

  # 2) Test + Build; Push a ECR SOLO en push a main (matriz)
  unit_tests:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.changed-services != '[]'
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.changed-services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies for ${{ matrix.service }}
        working-directory: ./services/${{ matrix.service }}
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          # Asegura herramientas de test y cobertura
          pip install pytest pytest-cov

      - name: Run unit tests with coverage for ${{ matrix.service }}
        working-directory: ./services/${{ matrix.service }}
        env:
          MIN_COVERAGE: ${{ env.MIN_COVERAGE }}
        run: |
          mkdir -p reports/html
          # Ejecuta pytest con cobertura y umbral m√≠nimo
          PYTHONPATH="$PWD:$PWD/src:$PYTHONPATH" pytest \
            --maxfail=1 \
            --disable-warnings \
            --junitxml=reports/junit.xml \
            --cov=src \
            --cov-config=/dev/null \
            --cov-report=xml:reports/coverage.xml \
            --cov-report=html:reports/html \
            --cov-fail-under=${MIN_COVERAGE}

      - name: Upload JUnit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-${{ matrix.service }}
          path: services/${{ matrix.service }}/reports/junit.xml
          if-no-files-found: warn

      - name: Upload coverage XML
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml-${{ matrix.service }}
          path: services/${{ matrix.service }}/reports/coverage.xml
          if-no-files-found: warn

      - name: Upload coverage HTML
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-html-${{ matrix.service }}
          path: services/${{ matrix.service }}/reports/html
          if-no-files-found: warn
  test_build_push:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.changed-services != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.changed-services) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
          cache: pip

      - name: Install deps
        working-directory: ./services/${{ matrix.service }}
        run: |
          pip install --upgrade pip
          pip install pytest pytest-cov flake8
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Lint
        working-directory: ./services/${{ matrix.service }}
        run: |
          echo "üîç flake8..."
          # Elimin√© el '|| true' para que el linting falle si encuentra errores E9, F63, etc.
          flake8 app.py --count --select=E9,F63,F7,F82 --show-source --statistics 
          flake8 app.py --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics 

      - name: Unit tests
        working-directory: ./services/${{ matrix.service }}
        run: |
          echo "üß™ pytest..."
          
          # 1. Ajuste de PYTHONPATH: A√±ade el directorio actual (donde reside 'src') al path.
          #    Esto permite importar 'src' como un m√≥dulo de nivel superior dentro del servicio,
          #    solucionando el conflicto entre Docker y los tests.
          export PYTHONPATH=$PYTHONPATH:$(pwd)
          
          # 2. FIX DE COBERTURA: Cambiamos --cov=app a --cov=src para medir el directorio principal.
          pytest --cov=src --cov-report=xml --cov-report=html --cov-fail-under=${{ env.MIN_COVERAGE }} -v
    

    # 3) Deploy a Producci√≥n (matrix)
  deploy_prod:
    needs: [detect-changes]
    if: github.ref == 'refs/heads/main' && needs.detect-changes.outputs.changed-services != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.changed-services) }}
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          COMMIT_SHA: ${{ github.sha }}
          SERVICE: ${{ matrix.service }}
          ECR_REPOSITORY: cdk-exp-container-assets-120569610818-us-east-1
        run: |
          IMAGE_TAG="$COMMIT_SHA-$SERVICE"

          # FULL_IMAGE_NAME = REGISTRY/REPOSITORY:TAG
          FULL_IMAGE_NAME="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          echo "‚öôÔ∏è  Obteniendo token de autenticaci√≥n de ECR para $ECR_REGISTRY..."
          aws ecr get-login-password \
              --region ${{ env.AWS_REGION }} \
          | docker login \
              --username AWS \
              --password-stdin $ECR_REGISTRY
          
          
          echo "Building image for $SERVICE with full name $FULL_IMAGE_NAME"
          docker build -t "$FULL_IMAGE_NAME" ./services/$SERVICE 
          
          echo "Pushing image $FULL_IMAGE_NAME to ECR"
          docker push "$FULL_IMAGE_NAME"

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy to ECS (Fargate) - Producci√≥n
        env:
           CLUSTER: ${{ env.ECS_CLUSTER }}
           SERVICE_SLUG: ${{ matrix.service }}
           AWS_REGION: ${{ env.AWS_REGION }}
           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
           COMMIT_SHA: ${{ github.sha }}
           ECR_REPOSITORY: cdk-exp-container-assets-120569610818-us-east-1
        run: |
            set -euo pipefail
            
            # 1. Crear el patr√≥n de b√∫squeda (Ej: ProductsService)
            SERVICE_SLUG_CAPITALIZED_PREFIX="$(echo "$SERVICE_SLUG" | sed 's/\(.\)/\U\1/')"Service
            
            echo "üîç Buscando servicio ECS que contenga: $SERVICE_SLUG_CAPITALIZED_PREFIX"
            
            # 2. OBTENCI√ìN ROBUSTA Y LIMPIA DEL NOMBRE LARGO CON JQ
            # -----------------------------------------------------------
            # A. Obtener todos los ARNs de servicio como JSON.
            # B. Filtrar el array de ARNs usando 'select' (que act√∫a como grep)
            #    para encontrar el ARN que contiene el patr√≥n capitalizado.
            # C. Extraer el nombre largo (el √∫ltimo segmento despu√©s del /)
            
            FULL_SERVICE_NAME=$(aws ecs list-services --cluster "$CLUSTER" --region "$AWS_REGION" --output json | \
                jq -r --arg prefix "$SERVICE_SLUG_CAPITALIZED_PREFIX" '.serviceArns[] | 
                    select(contains($prefix)) | 
                    split("/") | 
                    .[2]' || true) # El √≠ndice [2] es el nombre del servicio para ARN v2 (service/cluster/name)
            
            # -----------------------------------------------------------
            
            if [ -z "$FULL_SERVICE_NAME" ]; then
               echo "‚ùå ERROR FATAL: No se encontr√≥ ning√∫n servicio ECS que coincida con '$SERVICE_SLUG_CAPITALIZED_PREFIX' en el cluster '$CLUSTER'."
               exit 1
            fi
            
            # 3. OBTENCI√ìN ROBUSTA DEL TASK DEFINITION ARN (L√≥gica ya implementada)
            
            echo "üîé Obteniendo Definici√≥n de Tarea actual para $FULL_SERVICE_NAME..."
            
            SERVICE_DESC_JSON=$(aws ecs describe-services \
                --cluster "$CLUSTER" \
                --services "$FULL_SERVICE_NAME" \
                --region "$AWS_REGION" \
                --output json)
            
            # Usar jq para extraer de forma segura el TD_ARN
            TD_ARN=$(echo "$SERVICE_DESC_JSON" | jq -r '.services[0].taskDefinition')
            
            # 4. Verificaci√≥n de ARN
            if [ "$TD_ARN" == "null" ] || [ -z "$TD_ARN" ]; then
               echo "‚ùå ERROR: El servicio '$FULL_SERVICE_NAME' existe, pero no se pudo obtener el Task Definition ARN."
               exit 1
            fi
            
            # 5. Continuar el proceso de despliegue
            IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$COMMIT_SHA-$SERVICE_SLUG"
            echo "üöÄ Deploy $SERVICE_SLUG ‚Üí $FULL_SERVICE_NAME (TD: $TD_ARN) con imagen $IMAGE"
            
            # 6. Describir la Definici√≥n de Tarea
            aws ecs describe-task-definition --task-definition "$TD_ARN" --query 'taskDefinition' --region "$AWS_REGION" > base.json
            
            # 7. Manipulaci√≥n y Despliegue con JQ
            jq 'del(.status,.taskDefinitionArn,.requiresAttributes,.revision,.compatibilities,.registeredAt,.registeredBy)' base.json > stripped.json
            
            jq --arg S "$SERVICE_SLUG" --arg IMG "$IMAGE" '
              .containerDefinitions |= map(
                  # üü¢ MODIFICACI√ìN CLAVE: Usamos 'test' con el flag 'i' para una coincidencia flexible
                  if (.name | test($S; "i")) then 
                      .image = $IMG 
                  else 
                      . 
                  end
              )' stripped.json > rendered.json
            
            NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://rendered.json --query 'taskDefinition.taskDefinitionArn' --output text --region "$AWS_REGION")
            
            # Usamos $FULL_SERVICE_NAME para el update
            aws ecs update-service --cluster "$CLUSTER" --service "$FULL_SERVICE_NAME" --task-definition "$NEW_TD_ARN" --region "$AWS_REGION" >/dev/null
            
            echo "‚è≥ Esperando estabilidad..."
            # Usamos $FULL_SERVICE_NAME para esperar estabilidad
            aws ecs wait services-stable --cluster "$CLUSTER" --services "$FULL_SERVICE_NAME" --region "$AWS_REGION"
            
            echo "‚úÖ $SERVICE_SLUG desplegado en producci√≥n con $NEW_TD_ARN"

  # 4) Notificaci√≥n de PR (si aplica)
  pr_notification:
    needs: [detect-changes]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && needs.detect-changes.outputs.changed-services != '[]'
    steps:
      - name: PR Summary
        run: |
          echo "üìã RESUMEN DEL PULL REQUEST"
          echo "================================="
          echo "üîç PR #${{ needs.detect-changes.outputs.pr-number }}: ${{ needs.detect-changes.outputs.pr-title }}"
          echo "üåø Branch: ${{ github.head_ref }} ‚Üí ${{ github.base_ref }}"
          echo "üìä Microservicios afectados:"
          for s in $(jq -r '.[]' <<< '${{ needs.detect-changes.outputs.changed-services }}'); do
            echo "   ‚úÖ $s - Tests OK, imagen construida"
          done
          echo "================================="

  # 5) Cleanup local del runner
  cleanup:
    needs: [deploy_prod]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup docker
        run: |
          echo "üßπ Limpiando capas locales de Docker..."
          docker system prune -af || true
          echo "‚úÖ Cleanup completado"